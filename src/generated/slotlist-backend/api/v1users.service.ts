/**
 * slotlist.info API Documentation
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0-beta32
 * Contact: nick@slotlist.info
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { DeleteAccountResponse } from '../model/deleteAccountResponse';
import { GetUserDetailsResponse } from '../model/getUserDetailsResponse';
import { GetUserListResponse } from '../model/getUserListResponse';
import { GetUserMissionListResponse } from '../model/getUserMissionListResponse';
import { InternalServerError } from '../model/internalServerError';
import { Model13 } from '../model/model13';
import { Model88 } from '../model/model88';
import { Model89 } from '../model/model89';
import { ModifyUserDetailsResponse } from '../model/modifyUserDetailsResponse';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class V1usersService {

    protected basePath = 'https://api.slotlist.info';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Allows administrators to delete a specific user
     * Allows administrators to delete a specific user, permanentely removing all data related to their account from the database. This endpointcan only be used by administrators with the &#x60;admin.user&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param userUid UID of the user to delete
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteV1UsersUseruid(authorization: string, userUid: string, observe?: 'body', reportProgress?: boolean): Observable<DeleteAccountResponse>;
    public deleteV1UsersUseruid(authorization: string, userUid: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DeleteAccountResponse>>;
    public deleteV1UsersUseruid(authorization: string, userUid: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DeleteAccountResponse>>;
    public deleteV1UsersUseruid(authorization: string, userUid: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteV1UsersUseruid.');
        }
        if (userUid === null || userUid === undefined) {
            throw new Error('Required parameter userUid was null or undefined when calling deleteV1UsersUseruid.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<DeleteAccountResponse>(`${this.basePath}/v1/users/${encodeURIComponent(String(userUid))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a list of all currently existing users
     * Returns a paginated list of all currently existing users. Up to 100 users can be requested at once, pagination has to be used to retrieve the rest. No authentication is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, optional
     * @param limit Limit for number of users to retrieve, defaults to 25 (used for pagination in combination with offset)
     * @param offset Number of users to skip before retrieving new ones from database, defaults to 0 (used for pagination in combination with limit)
     * @param search Value used for searching users, retrieving only those that have a nickname containing the provided value
     * @param communityUid Optional filter for user search, restricting matches to only members of the community with the given UID. Only effective if a &#x60;search&#x60; value has been provided
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getV1Users(authorization?: string, limit?: number, offset?: number, search?: string, communityUid?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUserListResponse>;
    public getV1Users(authorization?: string, limit?: number, offset?: number, search?: string, communityUid?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUserListResponse>>;
    public getV1Users(authorization?: string, limit?: number, offset?: number, search?: string, communityUid?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUserListResponse>>;
    public getV1Users(authorization?: string, limit?: number, offset?: number, search?: string, communityUid?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (search !== undefined) {
            queryParameters = queryParameters.set('search', <any>search);
        }
        if (communityUid !== undefined) {
            queryParameters = queryParameters.set('communityUid', <any>communityUid);
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetUserListResponse>(`${this.basePath}/v1/users`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns details about a specific user
     * Returns more detailed information about a specific user, including a list of created missions. No authentication is required to access this endpoint
     * @param userUid UID of the user
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, optional
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getV1UsersUseruid(userUid: string, authorization?: string, observe?: 'body', reportProgress?: boolean): Observable<GetUserDetailsResponse>;
    public getV1UsersUseruid(userUid: string, authorization?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUserDetailsResponse>>;
    public getV1UsersUseruid(userUid: string, authorization?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUserDetailsResponse>>;
    public getV1UsersUseruid(userUid: string, authorization?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (userUid === null || userUid === undefined) {
            throw new Error('Required parameter userUid was null or undefined when calling getV1UsersUseruid.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetUserDetailsResponse>(`${this.basePath}/v1/users/${encodeURIComponent(String(userUid))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a list of missions for a specific user
     * Returns a paginated list of missions for a specific user, including already completed ones. No authentication is required to access this endpoint
     * @param userUid UID of the user
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, optional
     * @param limit Limit for number of missions to retrieve, defaults to 25 (used for pagination in combination with offset)
     * @param offset Number of missions to skip before retrieving new ones from database, defaults to 0 (used for pagination in combination with limit)
     * @param includeEnded Include ended missions in retrieved list, defaults to false
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getV1UsersUseruidMissions(userUid: string, authorization?: string, limit?: number, offset?: number, includeEnded?: boolean, observe?: 'body', reportProgress?: boolean): Observable<GetUserMissionListResponse>;
    public getV1UsersUseruidMissions(userUid: string, authorization?: string, limit?: number, offset?: number, includeEnded?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetUserMissionListResponse>>;
    public getV1UsersUseruidMissions(userUid: string, authorization?: string, limit?: number, offset?: number, includeEnded?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetUserMissionListResponse>>;
    public getV1UsersUseruidMissions(userUid: string, authorization?: string, limit?: number, offset?: number, includeEnded?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (userUid === null || userUid === undefined) {
            throw new Error('Required parameter userUid was null or undefined when calling getV1UsersUseruidMissions.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (includeEnded !== undefined) {
            queryParameters = queryParameters.set('includeEnded', <any>includeEnded);
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetUserMissionListResponse>(`${this.basePath}/v1/users/${encodeURIComponent(String(userUid))}/missions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Allows administrators to modify the details of a specific user
     * Allows administrators to modify the details of a specific user such as their nickname as well as to activate and deactivate their account. This endpointcan only be used by administrators with the &#x60;admin.user&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param userUid UID of the user to update
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchV1UsersUseruid(authorization: string, userUid: string, body?: Model88, observe?: 'body', reportProgress?: boolean): Observable<ModifyUserDetailsResponse>;
    public patchV1UsersUseruid(authorization: string, userUid: string, body?: Model88, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModifyUserDetailsResponse>>;
    public patchV1UsersUseruid(authorization: string, userUid: string, body?: Model88, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModifyUserDetailsResponse>>;
    public patchV1UsersUseruid(authorization: string, userUid: string, body?: Model88, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling patchV1UsersUseruid.');
        }
        if (userUid === null || userUid === undefined) {
            throw new Error('Required parameter userUid was null or undefined when calling patchV1UsersUseruid.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.patch<ModifyUserDetailsResponse>(`${this.basePath}/v1/users/${encodeURIComponent(String(userUid))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}

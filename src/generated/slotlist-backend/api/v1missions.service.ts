/**
 * slotlist.info API Documentation
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0-beta32
 * Contact: nick@slotlist.info
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { ApplyMissionSlotTemplateResponse } from '../model/applyMissionSlotTemplateResponse';
import { AssignMissionSlotResponse } from '../model/assignMissionSlotResponse';
import { CreateMissionAccessResponse } from '../model/createMissionAccessResponse';
import { CreateMissionPermissionResponse } from '../model/createMissionPermissionResponse';
import { CreateMissionResponse } from '../model/createMissionResponse';
import { CreateMissionSlotGroupResponse } from '../model/createMissionSlotGroupResponse';
import { CreateMissionSlotRegistrationResponse } from '../model/createMissionSlotRegistrationResponse';
import { CreateMissionSlotResponse } from '../model/createMissionSlotResponse';
import { DeleteAccountResponse } from '../model/deleteAccountResponse';
import { DeleteCommunityResponse } from '../model/deleteCommunityResponse';
import { DuplicateMissionResponse } from '../model/duplicateMissionResponse';
import { Forbidden } from '../model/forbidden';
import { GenerateMissionTokenResponse } from '../model/generateMissionTokenResponse';
import { GetMissionAccessListResponse } from '../model/getMissionAccessListResponse';
import { GetMissionDetailsResponse } from '../model/getMissionDetailsResponse';
import { GetMissionListResponse } from '../model/getMissionListResponse';
import { GetMissionPermissionListResponse } from '../model/getMissionPermissionListResponse';
import { GetMissionSlotListResponse } from '../model/getMissionSlotListResponse';
import { GetMissionSlotRegistrationListResponse } from '../model/getMissionSlotRegistrationListResponse';
import { GetMissionTokenResponse } from '../model/getMissionTokenResponse';
import { InternalServerError } from '../model/internalServerError';
import { IsCommunitySlugAvailableResponse } from '../model/isCommunitySlugAvailableResponse';
import { Model100 } from '../model/model100';
import { Model101 } from '../model/model101';
import { Model103 } from '../model/model103';
import { Model106 } from '../model/model106';
import { Model107 } from '../model/model107';
import { Model108 } from '../model/model108';
import { Model110 } from '../model/model110';
import { Model12 } from '../model/model12';
import { Model2 } from '../model/model2';
import { Model23 } from '../model/model23';
import { Model36 } from '../model/model36';
import { Model43 } from '../model/model43';
import { Model44 } from '../model/model44';
import { Model53 } from '../model/model53';
import { Model54 } from '../model/model54';
import { Model55 } from '../model/model55';
import { Model56 } from '../model/model56';
import { Model57 } from '../model/model57';
import { Model58 } from '../model/model58';
import { Model61 } from '../model/model61';
import { Model63 } from '../model/model63';
import { Model64 } from '../model/model64';
import { Model65 } from '../model/model65';
import { Model67 } from '../model/model67';
import { Model68 } from '../model/model68';
import { Model69 } from '../model/model69';
import { Model70 } from '../model/model70';
import { Model71 } from '../model/model71';
import { Model72 } from '../model/model72';
import { Model74 } from '../model/model74';
import { Model75 } from '../model/model75';
import { Model76 } from '../model/model76';
import { Model77 } from '../model/model77';
import { Model87 } from '../model/model87';
import { Model93 } from '../model/model93';
import { Model94 } from '../model/model94';
import { Model96 } from '../model/model96';
import { Model97 } from '../model/model97';
import { Model98 } from '../model/model98';
import { UnassignMissionSlotResponse } from '../model/unassignMissionSlotResponse';
import { UpdateMissionResponse } from '../model/updateMissionResponse';
import { UpdateMissionSlotRegistrationResponse } from '../model/updateMissionSlotRegistrationResponse';
import { UpdateMissionSlotResponse } from '../model/updateMissionSlotResponse';
import { UpdatedMissionSlotGroupResponse } from '../model/updatedMissionSlotGroupResponse';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class V1missionsService {

    protected basePath = 'https://api.slotlist.info';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Deletes an existing mission
     * Deletes an existing mission, including all associated missions slots and mission slot registrations. This endpoint can only be used by mission creators. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to delete
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteV1MissionsMissionslug(authorization: string, missionSlug: string, observe?: 'body', reportProgress?: boolean): Observable<DeleteCommunityResponse>;
    public deleteV1MissionsMissionslug(authorization: string, missionSlug: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DeleteCommunityResponse>>;
    public deleteV1MissionsMissionslug(authorization: string, missionSlug: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DeleteCommunityResponse>>;
    public deleteV1MissionsMissionslug(authorization: string, missionSlug: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteV1MissionsMissionslug.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling deleteV1MissionsMissionslug.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<DeleteCommunityResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes an existing mission access
     * Deletes an existing mission access. This endpoint can only be used by mission creators and users with the &#x60;mission.SLUG.editor&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to delete access for
     * @param missionAccessUid UID of the mission access to delete
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteV1MissionsMissionslugAccessesMissionaccessuid(authorization: string, missionSlug: string, missionAccessUid: string, observe?: 'body', reportProgress?: boolean): Observable<DeleteAccountResponse>;
    public deleteV1MissionsMissionslugAccessesMissionaccessuid(authorization: string, missionSlug: string, missionAccessUid: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DeleteAccountResponse>>;
    public deleteV1MissionsMissionslugAccessesMissionaccessuid(authorization: string, missionSlug: string, missionAccessUid: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DeleteAccountResponse>>;
    public deleteV1MissionsMissionslugAccessesMissionaccessuid(authorization: string, missionSlug: string, missionAccessUid: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteV1MissionsMissionslugAccessesMissionaccessuid.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling deleteV1MissionsMissionslugAccessesMissionaccessuid.');
        }
        if (missionAccessUid === null || missionAccessUid === undefined) {
            throw new Error('Required parameter missionAccessUid was null or undefined when calling deleteV1MissionsMissionslugAccessesMissionaccessuid.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<DeleteAccountResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/accesses/${encodeURIComponent(String(missionAccessUid))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes an existing mission banner image
     * Deletes an existing mission banner image, also removing it from GCP storage. This endpoint can only be used by mission creators and users with the &#x60;mission.SLUG.editor&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to delete the mission image for
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteV1MissionsMissionslugBannerimage(authorization: string, missionSlug: string, observe?: 'body', reportProgress?: boolean): Observable<DeleteAccountResponse>;
    public deleteV1MissionsMissionslugBannerimage(authorization: string, missionSlug: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DeleteAccountResponse>>;
    public deleteV1MissionsMissionslugBannerimage(authorization: string, missionSlug: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DeleteAccountResponse>>;
    public deleteV1MissionsMissionslugBannerimage(authorization: string, missionSlug: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteV1MissionsMissionslugBannerimage.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling deleteV1MissionsMissionslugBannerimage.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<DeleteAccountResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/bannerImage`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes an existing mission permission
     * Deletes an existing mission permission. This endpoint can only be used by mission creators. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to delete permission for
     * @param permissionUid UID of the mission permission to delete
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteV1MissionsMissionslugPermissionsPermissionuid(authorization: string, missionSlug: string, permissionUid: string, observe?: 'body', reportProgress?: boolean): Observable<DeleteAccountResponse>;
    public deleteV1MissionsMissionslugPermissionsPermissionuid(authorization: string, missionSlug: string, permissionUid: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DeleteAccountResponse>>;
    public deleteV1MissionsMissionslugPermissionsPermissionuid(authorization: string, missionSlug: string, permissionUid: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DeleteAccountResponse>>;
    public deleteV1MissionsMissionslugPermissionsPermissionuid(authorization: string, missionSlug: string, permissionUid: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteV1MissionsMissionslugPermissionsPermissionuid.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling deleteV1MissionsMissionslugPermissionsPermissionuid.');
        }
        if (permissionUid === null || permissionUid === undefined) {
            throw new Error('Required parameter permissionUid was null or undefined when calling deleteV1MissionsMissionslugPermissionsPermissionuid.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<DeleteAccountResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/permissions/${encodeURIComponent(String(permissionUid))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes an existing mission slot group
     * Deletes an existing mission slot group and all slots associated with it. This endpoint can only be used by mission creators and users with the &#x60;mission.SLUG.editor&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to delete slot group for
     * @param slotGroupUid UID of the mission slot group to delete
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteV1MissionsMissionslugSlotgroupsSlotgroupuid(authorization: string, missionSlug: string, slotGroupUid: string, observe?: 'body', reportProgress?: boolean): Observable<DeleteAccountResponse>;
    public deleteV1MissionsMissionslugSlotgroupsSlotgroupuid(authorization: string, missionSlug: string, slotGroupUid: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DeleteAccountResponse>>;
    public deleteV1MissionsMissionslugSlotgroupsSlotgroupuid(authorization: string, missionSlug: string, slotGroupUid: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DeleteAccountResponse>>;
    public deleteV1MissionsMissionslugSlotgroupsSlotgroupuid(authorization: string, missionSlug: string, slotGroupUid: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteV1MissionsMissionslugSlotgroupsSlotgroupuid.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling deleteV1MissionsMissionslugSlotgroupsSlotgroupuid.');
        }
        if (slotGroupUid === null || slotGroupUid === undefined) {
            throw new Error('Required parameter slotGroupUid was null or undefined when calling deleteV1MissionsMissionslugSlotgroupsSlotgroupuid.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<DeleteAccountResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/slotGroups/${encodeURIComponent(String(slotGroupUid))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes an existing mission slot
     * Deletes an existing mission slot, including all associated mission slot registrations. This endpoint can only be used by mission creators and users with the &#x60;mission.SLUG.editor&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to delete the slot for
     * @param slotUid UID of the mission slot to delete
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteV1MissionsMissionslugSlotsSlotuid(authorization: string, missionSlug: string, slotUid: string, observe?: 'body', reportProgress?: boolean): Observable<DeleteAccountResponse>;
    public deleteV1MissionsMissionslugSlotsSlotuid(authorization: string, missionSlug: string, slotUid: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DeleteAccountResponse>>;
    public deleteV1MissionsMissionslugSlotsSlotuid(authorization: string, missionSlug: string, slotUid: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DeleteAccountResponse>>;
    public deleteV1MissionsMissionslugSlotsSlotuid(authorization: string, missionSlug: string, slotUid: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteV1MissionsMissionslugSlotsSlotuid.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling deleteV1MissionsMissionslugSlotsSlotuid.');
        }
        if (slotUid === null || slotUid === undefined) {
            throw new Error('Required parameter slotUid was null or undefined when calling deleteV1MissionsMissionslugSlotsSlotuid.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<DeleteAccountResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/slots/${encodeURIComponent(String(slotUid))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes an existing mission slot registration
     * Allows a user to delete their mission slot registration. Registrations can only be deleted by the user that created them or by mission creators and userswith the &#x60;mission.SLUG.editor&#x60; permission. Regular user authentication required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to delete the slot registrations for
     * @param slotUid UID of the mission slot to delete registrations for
     * @param registrationUid UID of the mission slot registration to delete
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteV1MissionsMissionslugSlotsSlotuidRegistrationsRegistrationuid(authorization: string, missionSlug: string, slotUid: string, registrationUid: string, observe?: 'body', reportProgress?: boolean): Observable<DeleteAccountResponse>;
    public deleteV1MissionsMissionslugSlotsSlotuidRegistrationsRegistrationuid(authorization: string, missionSlug: string, slotUid: string, registrationUid: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DeleteAccountResponse>>;
    public deleteV1MissionsMissionslugSlotsSlotuidRegistrationsRegistrationuid(authorization: string, missionSlug: string, slotUid: string, registrationUid: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DeleteAccountResponse>>;
    public deleteV1MissionsMissionslugSlotsSlotuidRegistrationsRegistrationuid(authorization: string, missionSlug: string, slotUid: string, registrationUid: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteV1MissionsMissionslugSlotsSlotuidRegistrationsRegistrationuid.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling deleteV1MissionsMissionslugSlotsSlotuidRegistrationsRegistrationuid.');
        }
        if (slotUid === null || slotUid === undefined) {
            throw new Error('Required parameter slotUid was null or undefined when calling deleteV1MissionsMissionslugSlotsSlotuidRegistrationsRegistrationuid.');
        }
        if (registrationUid === null || registrationUid === undefined) {
            throw new Error('Required parameter registrationUid was null or undefined when calling deleteV1MissionsMissionslugSlotsSlotuidRegistrationsRegistrationuid.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<DeleteAccountResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/slots/${encodeURIComponent(String(slotUid))}/registrations/${encodeURIComponent(String(registrationUid))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes the mission token
     * Deletes the mission token, performing no operation if no token was generated before. This endpoint can only be used by mission creators. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to delete token for
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteV1MissionsMissionslugToken(authorization: string, missionSlug: string, observe?: 'body', reportProgress?: boolean): Observable<DeleteAccountResponse>;
    public deleteV1MissionsMissionslugToken(authorization: string, missionSlug: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DeleteAccountResponse>>;
    public deleteV1MissionsMissionslugToken(authorization: string, missionSlug: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DeleteAccountResponse>>;
    public deleteV1MissionsMissionslugToken(authorization: string, missionSlug: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteV1MissionsMissionslugToken.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling deleteV1MissionsMissionslugToken.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<DeleteAccountResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/token`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a list of all currently created missions
     * Returns a paginated list of all currently created mission. Up to 100 mission can be requested at once, pagination has to be used to retrieve the rest. By default, only missions that have not ended yet are being displayed. No authentication is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, optional
     * @param limit Limit for number of missions to retrieve, defaults to 25 (used for pagination in combination with offset)
     * @param offset Number of missions to skip before retrieving new ones from database, defaults to 0 (used for pagination in combination with limit)
     * @param includeEnded Include ended missions in retrieved list, defaults to false
     * @param startDate Date and time (in UTC) to start retrieving missions from. Used for mission calendar, to be used in conjunction with &#x60;endDate&#x60;. Endpoint ignores all other query parameters provided if a &#x60;startDate&#x60; has been provided
     * @param endDate Date and time (in UTC) to end retrieving missions, inclusive. Used for mission calendar, to be used in conjunction with &#x60;startDate&#x60;. Must be provided if &#x60;startDate&#x60; has been set
     * @param search Value used for searching missions, retrieving only those that have a title containing the provided value
     * @param communityUid Optional filter for mission search, restricting matches to only missions associated with the community with the given UID. Only effective if a &#x60;search&#x60; value has been provided, mutually exclusive with the &#x60;creatorUid&#x60; parameter
     * @param creatorUid Optional filter for mission search, restricting matches to only missions created by the user with the given UID. Only effective if a &#x60;search&#x60; value has been provided, mutually exclusive with the &#x60;communityUid&#x60; parameter
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getV1Missions(authorization?: string, limit?: number, offset?: number, includeEnded?: boolean, startDate?: string, endDate?: string, search?: string, communityUid?: string, creatorUid?: string, observe?: 'body', reportProgress?: boolean): Observable<GetMissionListResponse>;
    public getV1Missions(authorization?: string, limit?: number, offset?: number, includeEnded?: boolean, startDate?: string, endDate?: string, search?: string, communityUid?: string, creatorUid?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetMissionListResponse>>;
    public getV1Missions(authorization?: string, limit?: number, offset?: number, includeEnded?: boolean, startDate?: string, endDate?: string, search?: string, communityUid?: string, creatorUid?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetMissionListResponse>>;
    public getV1Missions(authorization?: string, limit?: number, offset?: number, includeEnded?: boolean, startDate?: string, endDate?: string, search?: string, communityUid?: string, creatorUid?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (includeEnded !== undefined) {
            queryParameters = queryParameters.set('includeEnded', <any>includeEnded);
        }
        if (startDate !== undefined) {
            queryParameters = queryParameters.set('startDate', <any>startDate);
        }
        if (endDate !== undefined) {
            queryParameters = queryParameters.set('endDate', <any>endDate);
        }
        if (search !== undefined) {
            queryParameters = queryParameters.set('search', <any>search);
        }
        if (communityUid !== undefined) {
            queryParameters = queryParameters.set('communityUid', <any>communityUid);
        }
        if (creatorUid !== undefined) {
            queryParameters = queryParameters.set('creatorUid', <any>creatorUid);
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetMissionListResponse>(`${this.basePath}/v1/missions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns details about a specific mission
     * Returns more detailed information about a specific mission, including more detailed mission times as well as a longer description and additional information required for participating. No authentication is required to access this endpoint
     * @param missionSlug Slug of mission to retrieve
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, optional
     * @param missionToken Optional (mission) API token used for static authentication, only valid for this mission. If provided, grants regular user access to the mission, even if its visibility is not public and no regular authentication was provided
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getV1MissionsMissionslug(missionSlug: string, authorization?: string, missionToken?: string, observe?: 'body', reportProgress?: boolean): Observable<GetMissionDetailsResponse>;
    public getV1MissionsMissionslug(missionSlug: string, authorization?: string, missionToken?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetMissionDetailsResponse>>;
    public getV1MissionsMissionslug(missionSlug: string, authorization?: string, missionToken?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetMissionDetailsResponse>>;
    public getV1MissionsMissionslug(missionSlug: string, authorization?: string, missionToken?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling getV1MissionsMissionslug.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (missionToken !== undefined) {
            queryParameters = queryParameters.set('missionToken', <any>missionToken);
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetMissionDetailsResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a list of all accesses granted for the given mission
     * Returns a list of all accesses granted for the given mission. This endpoint can only be used by mission creators and users with the &#x60;mission.SLUG.editor&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to retrieve accesses for
     * @param limit Limit for number of accesses to retrieve, defaults to 25 (used for pagination in combination with offset)
     * @param offset Number of access to skip before retrieving new ones from database, defaults to 0 (used for pagination in combination with limit)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getV1MissionsMissionslugAccesses(authorization: string, missionSlug: string, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean): Observable<GetMissionAccessListResponse>;
    public getV1MissionsMissionslugAccesses(authorization: string, missionSlug: string, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetMissionAccessListResponse>>;
    public getV1MissionsMissionslugAccesses(authorization: string, missionSlug: string, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetMissionAccessListResponse>>;
    public getV1MissionsMissionslugAccesses(authorization: string, missionSlug: string, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getV1MissionsMissionslugAccesses.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling getV1MissionsMissionslugAccesses.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetMissionAccessListResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/accesses`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a list of all permissions granted for the given mission
     * Returns a list of permissions granted for the given mission. This endpoint can only be used by mission creators. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to retrieve permissions for
     * @param limit Limit for number of permissions to retrieve, defaults to 25 (used for pagination in combination with offset)
     * @param offset Number of permissions to skip before retrieving new ones from database, defaults to 0 (used for pagination in combination with limit)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getV1MissionsMissionslugPermissions(authorization: string, missionSlug: string, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean): Observable<GetMissionPermissionListResponse>;
    public getV1MissionsMissionslugPermissions(authorization: string, missionSlug: string, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetMissionPermissionListResponse>>;
    public getV1MissionsMissionslugPermissions(authorization: string, missionSlug: string, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetMissionPermissionListResponse>>;
    public getV1MissionsMissionslugPermissions(authorization: string, missionSlug: string, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getV1MissionsMissionslugPermissions.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling getV1MissionsMissionslugPermissions.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetMissionPermissionListResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/permissions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a list of all slots (in their respective slot groups) for the given mission
     * Returns a list of slots (in their respective slot groups) for the given mission. Due to the separation into groups, no pagiation can be provided. No authentication is required to access this endpoint
     * @param missionSlug Slug of mission to retrieve slots for
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, optional
     * @param missionToken Optional (mission) API token used for static authentication, only valid for this mission. If provided, grants regular user access to the mission, even if its visibility is not public and no regular authentication was provided
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getV1MissionsMissionslugSlots(missionSlug: string, authorization?: string, missionToken?: string, observe?: 'body', reportProgress?: boolean): Observable<GetMissionSlotListResponse>;
    public getV1MissionsMissionslugSlots(missionSlug: string, authorization?: string, missionToken?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetMissionSlotListResponse>>;
    public getV1MissionsMissionslugSlots(missionSlug: string, authorization?: string, missionToken?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetMissionSlotListResponse>>;
    public getV1MissionsMissionslugSlots(missionSlug: string, authorization?: string, missionToken?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling getV1MissionsMissionslugSlots.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (missionToken !== undefined) {
            queryParameters = queryParameters.set('missionToken', <any>missionToken);
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetMissionSlotListResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/slots`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a list of registrations for the selected slot for the given mission
     * Returns a paginated list of registrations for the selected slot for the given mission. This endpoint can be used by all users, however mission creators and users with the &#x60;mission.SLUG.editor&#x60; permission receive additional details. No authentication is required to access this endpoint
     * @param missionSlug Slug of mission to retrieve the slot registrations for
     * @param slotUid UID of the mission slot to retrieve registrations for
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, optional
     * @param limit Limit for number of registrations to retrieve, defaults to 25 (used for pagination in combination with offset)
     * @param offset Number of registrations to skip before retrieving new ones from database, defaults to 0 (used for pagination in combination with limit)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getV1MissionsMissionslugSlotsSlotuidRegistrations(missionSlug: string, slotUid: string, authorization?: string, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean): Observable<GetMissionSlotRegistrationListResponse>;
    public getV1MissionsMissionslugSlotsSlotuidRegistrations(missionSlug: string, slotUid: string, authorization?: string, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetMissionSlotRegistrationListResponse>>;
    public getV1MissionsMissionslugSlotsSlotuidRegistrations(missionSlug: string, slotUid: string, authorization?: string, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetMissionSlotRegistrationListResponse>>;
    public getV1MissionsMissionslugSlotsSlotuidRegistrations(missionSlug: string, slotUid: string, authorization?: string, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling getV1MissionsMissionslugSlotsSlotuidRegistrations.');
        }
        if (slotUid === null || slotUid === undefined) {
            throw new Error('Required parameter slotUid was null or undefined when calling getV1MissionsMissionslugSlotsSlotuidRegistrations.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetMissionSlotRegistrationListResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/slots/${encodeURIComponent(String(slotUid))}/registrations`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns the mission API token used for static authentication
     * Returns the mission API token used for static authentication, granting user access to this mission without requiring regular auth. This endpoint can only be used by mission creators. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to retrieve mission token for
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getV1MissionsMissionslugToken(authorization: string, missionSlug: string, observe?: 'body', reportProgress?: boolean): Observable<GetMissionTokenResponse>;
    public getV1MissionsMissionslugToken(authorization: string, missionSlug: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetMissionTokenResponse>>;
    public getV1MissionsMissionslugToken(authorization: string, missionSlug: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetMissionTokenResponse>>;
    public getV1MissionsMissionslugToken(authorization: string, missionSlug: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getV1MissionsMissionslugToken.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling getV1MissionsMissionslugToken.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetMissionTokenResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/token`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Checks whether the given slug is available
     * Checks whether the given slug is available and can be used for a new mission. No authentication is required to access this endpoint
     * @param slug Slug to check availability for
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, optional
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getV1MissionsSlugavailable(slug: string, authorization?: string, observe?: 'body', reportProgress?: boolean): Observable<IsCommunitySlugAvailableResponse>;
    public getV1MissionsSlugavailable(slug: string, authorization?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IsCommunitySlugAvailableResponse>>;
    public getV1MissionsSlugavailable(slug: string, authorization?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IsCommunitySlugAvailableResponse>>;
    public getV1MissionsSlugavailable(slug: string, authorization?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (slug === null || slug === undefined) {
            throw new Error('Required parameter slug was null or undefined when calling getV1MissionsSlugavailable.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (slug !== undefined) {
            queryParameters = queryParameters.set('slug', <any>slug);
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<IsCommunitySlugAvailableResponse>(`${this.basePath}/v1/missions/slugAvailable`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates an existing mission
     * Updates the mutable attributes of a mission. This endpoint can only be used by mission creators and users with the &#x60;mission.SLUG.editor&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to update
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchV1MissionsMissionslug(authorization: string, missionSlug: string, body?: Model87, observe?: 'body', reportProgress?: boolean): Observable<UpdateMissionResponse>;
    public patchV1MissionsMissionslug(authorization: string, missionSlug: string, body?: Model87, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UpdateMissionResponse>>;
    public patchV1MissionsMissionslug(authorization: string, missionSlug: string, body?: Model87, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UpdateMissionResponse>>;
    public patchV1MissionsMissionslug(authorization: string, missionSlug: string, body?: Model87, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling patchV1MissionsMissionslug.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling patchV1MissionsMissionslug.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.patch<UpdateMissionResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updated an existing mission slot group
     * Updates an existing mission slot group. This endpoint can only be used by mission creators and users with the &#x60;mission.SLUG.editor&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to update slot group for
     * @param slotGroupUid UID of the mission slot group to update
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchV1MissionsMissionslugSlotgroupsSlotgroupuid(authorization: string, missionSlug: string, slotGroupUid: string, body?: Model93, observe?: 'body', reportProgress?: boolean): Observable<UpdatedMissionSlotGroupResponse>;
    public patchV1MissionsMissionslugSlotgroupsSlotgroupuid(authorization: string, missionSlug: string, slotGroupUid: string, body?: Model93, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UpdatedMissionSlotGroupResponse>>;
    public patchV1MissionsMissionslugSlotgroupsSlotgroupuid(authorization: string, missionSlug: string, slotGroupUid: string, body?: Model93, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UpdatedMissionSlotGroupResponse>>;
    public patchV1MissionsMissionslugSlotgroupsSlotgroupuid(authorization: string, missionSlug: string, slotGroupUid: string, body?: Model93, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling patchV1MissionsMissionslugSlotgroupsSlotgroupuid.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling patchV1MissionsMissionslugSlotgroupsSlotgroupuid.');
        }
        if (slotGroupUid === null || slotGroupUid === undefined) {
            throw new Error('Required parameter slotGroupUid was null or undefined when calling patchV1MissionsMissionslugSlotgroupsSlotgroupuid.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.patch<UpdatedMissionSlotGroupResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/slotGroups/${encodeURIComponent(String(slotGroupUid))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates an existing mission slot
     * Updates the mutable attributes of a mission slot. This endpoint can only be used by mission creators and users with the &#x60;mission.SLUG.editor&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to update the slot for
     * @param slotUid UID of the mission slot to update
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchV1MissionsMissionslugSlotsSlotuid(authorization: string, missionSlug: string, slotUid: string, body?: Model96, observe?: 'body', reportProgress?: boolean): Observable<UpdateMissionSlotResponse>;
    public patchV1MissionsMissionslugSlotsSlotuid(authorization: string, missionSlug: string, slotUid: string, body?: Model96, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UpdateMissionSlotResponse>>;
    public patchV1MissionsMissionslugSlotsSlotuid(authorization: string, missionSlug: string, slotUid: string, body?: Model96, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UpdateMissionSlotResponse>>;
    public patchV1MissionsMissionslugSlotsSlotuid(authorization: string, missionSlug: string, slotUid: string, body?: Model96, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling patchV1MissionsMissionslugSlotsSlotuid.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling patchV1MissionsMissionslugSlotsSlotuid.');
        }
        if (slotUid === null || slotUid === undefined) {
            throw new Error('Required parameter slotUid was null or undefined when calling patchV1MissionsMissionslugSlotsSlotuid.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.patch<UpdateMissionSlotResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/slots/${encodeURIComponent(String(slotUid))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates an existing mission slot registration
     * Updates the mutable attributes of a mission slot registration, allowing for registrations to be accepted or changed. Confirming a mission slot sets the assignee for the respective slot. Changing an already confirmed registration to unconfirmed removes the assignee again and allows for another assignment. This endpoint can only be used by mission creators and users with the &#x60;mission.SLUG.editor&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to update the slot registrations for
     * @param slotUid UID of the mission slot to update registrations for
     * @param registrationUid UID of the mission slot registration to update
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchV1MissionsMissionslugSlotsSlotuidRegistrationsRegistrationuid(authorization: string, missionSlug: string, slotUid: string, registrationUid: string, body?: Model98, observe?: 'body', reportProgress?: boolean): Observable<UpdateMissionSlotRegistrationResponse>;
    public patchV1MissionsMissionslugSlotsSlotuidRegistrationsRegistrationuid(authorization: string, missionSlug: string, slotUid: string, registrationUid: string, body?: Model98, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UpdateMissionSlotRegistrationResponse>>;
    public patchV1MissionsMissionslugSlotsSlotuidRegistrationsRegistrationuid(authorization: string, missionSlug: string, slotUid: string, registrationUid: string, body?: Model98, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UpdateMissionSlotRegistrationResponse>>;
    public patchV1MissionsMissionslugSlotsSlotuidRegistrationsRegistrationuid(authorization: string, missionSlug: string, slotUid: string, registrationUid: string, body?: Model98, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling patchV1MissionsMissionslugSlotsSlotuidRegistrationsRegistrationuid.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling patchV1MissionsMissionslugSlotsSlotuidRegistrationsRegistrationuid.');
        }
        if (slotUid === null || slotUid === undefined) {
            throw new Error('Required parameter slotUid was null or undefined when calling patchV1MissionsMissionslugSlotsSlotuidRegistrationsRegistrationuid.');
        }
        if (registrationUid === null || registrationUid === undefined) {
            throw new Error('Required parameter registrationUid was null or undefined when calling patchV1MissionsMissionslugSlotsSlotuidRegistrationsRegistrationuid.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.patch<UpdateMissionSlotRegistrationResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/slots/${encodeURIComponent(String(slotUid))}/registrations/${encodeURIComponent(String(registrationUid))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new mission
     * Creates a new mission and assigns the current user as its creator. The user can optionally also associate the mission with their community. Regular user authentication is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postV1Missions(authorization: string, body?: Model43, observe?: 'body', reportProgress?: boolean): Observable<CreateMissionResponse>;
    public postV1Missions(authorization: string, body?: Model43, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CreateMissionResponse>>;
    public postV1Missions(authorization: string, body?: Model43, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CreateMissionResponse>>;
    public postV1Missions(authorization: string, body?: Model43, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling postV1Missions.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<CreateMissionResponse>(`${this.basePath}/v1/missions`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new mission access for the given mission
     * Creates a new mission access for the given mission. This endpoint can only be used by mission creators and users with the &#x60;mission.SLUG.editor&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to create access for
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postV1MissionsMissionslugAccesses(authorization: string, missionSlug: string, body?: Model56, observe?: 'body', reportProgress?: boolean): Observable<CreateMissionAccessResponse>;
    public postV1MissionsMissionslugAccesses(authorization: string, missionSlug: string, body?: Model56, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CreateMissionAccessResponse>>;
    public postV1MissionsMissionslugAccesses(authorization: string, missionSlug: string, body?: Model56, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CreateMissionAccessResponse>>;
    public postV1MissionsMissionslugAccesses(authorization: string, missionSlug: string, body?: Model56, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling postV1MissionsMissionslugAccesses.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling postV1MissionsMissionslugAccesses.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<CreateMissionAccessResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/accesses`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Duplicates an exiting mission
     * Duplicates an existing mission using the provided new mission slug. All mission times can also be specified and thus overwritten, defaulting to the current mission&#39;s times if omitted. This endpoint can only be used by mission creators and users with the &#x60;mission.SLUG.editor&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to create permission for
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postV1MissionsMissionslugDuplicate(authorization: string, missionSlug: string, body?: Model63, observe?: 'body', reportProgress?: boolean): Observable<DuplicateMissionResponse>;
    public postV1MissionsMissionslugDuplicate(authorization: string, missionSlug: string, body?: Model63, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DuplicateMissionResponse>>;
    public postV1MissionsMissionslugDuplicate(authorization: string, missionSlug: string, body?: Model63, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DuplicateMissionResponse>>;
    public postV1MissionsMissionslugDuplicate(authorization: string, missionSlug: string, body?: Model63, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling postV1MissionsMissionslugDuplicate.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling postV1MissionsMissionslugDuplicate.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<DuplicateMissionResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/duplicate`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new mission permission for the given mission
     * Creates a new mission permission for the given mission. This endpoint can only be used by mission creators. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to create permission for
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postV1MissionsMissionslugPermissions(authorization: string, missionSlug: string, body?: Model53, observe?: 'body', reportProgress?: boolean): Observable<CreateMissionPermissionResponse>;
    public postV1MissionsMissionslugPermissions(authorization: string, missionSlug: string, body?: Model53, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CreateMissionPermissionResponse>>;
    public postV1MissionsMissionslugPermissions(authorization: string, missionSlug: string, body?: Model53, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CreateMissionPermissionResponse>>;
    public postV1MissionsMissionslugPermissions(authorization: string, missionSlug: string, body?: Model53, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling postV1MissionsMissionslugPermissions.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling postV1MissionsMissionslugPermissions.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<CreateMissionPermissionResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/permissions`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new mission slot group for the given mission
     * Creates a new mission slot group for the given mission. This endpoint can only be used by mission creators and users with the &#x60;mission.SLUG.editor&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to create slots for
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postV1MissionsMissionslugSlotgroups(authorization: string, missionSlug: string, body?: Model64, observe?: 'body', reportProgress?: boolean): Observable<CreateMissionSlotGroupResponse>;
    public postV1MissionsMissionslugSlotgroups(authorization: string, missionSlug: string, body?: Model64, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CreateMissionSlotGroupResponse>>;
    public postV1MissionsMissionslugSlotgroups(authorization: string, missionSlug: string, body?: Model64, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CreateMissionSlotGroupResponse>>;
    public postV1MissionsMissionslugSlotgroups(authorization: string, missionSlug: string, body?: Model64, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling postV1MissionsMissionslugSlotgroups.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling postV1MissionsMissionslugSlotgroups.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<CreateMissionSlotGroupResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/slotGroups`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates one or multiple new slots for the given mission
     * Creates one or multiple new slots for the given mission. This endpoint can only be used by mission creators and users with the &#x60;mission.SLUG.editor&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to create slots for
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postV1MissionsMissionslugSlots(authorization: string, missionSlug: string, body?: Model61, observe?: 'body', reportProgress?: boolean): Observable<CreateMissionSlotResponse>;
    public postV1MissionsMissionslugSlots(authorization: string, missionSlug: string, body?: Model61, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CreateMissionSlotResponse>>;
    public postV1MissionsMissionslugSlots(authorization: string, missionSlug: string, body?: Model61, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CreateMissionSlotResponse>>;
    public postV1MissionsMissionslugSlots(authorization: string, missionSlug: string, body?: Model61, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling postV1MissionsMissionslugSlots.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling postV1MissionsMissionslugSlots.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<CreateMissionSlotResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/slots`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Assigns a user to an existing mission slot
     * Assigns a user to an existing mission slot, creating a registration for them. This endpoint can only be used by mission creators and users with the &#x60;mission.SLUG.editor&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to assign user to slot
     * @param slotUid UID of the mission slot to assign user to
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postV1MissionsMissionslugSlotsSlotuidAssign(authorization: string, missionSlug: string, slotUid: string, body?: Model68, observe?: 'body', reportProgress?: boolean): Observable<AssignMissionSlotResponse>;
    public postV1MissionsMissionslugSlotsSlotuidAssign(authorization: string, missionSlug: string, slotUid: string, body?: Model68, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AssignMissionSlotResponse>>;
    public postV1MissionsMissionslugSlotsSlotuidAssign(authorization: string, missionSlug: string, slotUid: string, body?: Model68, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AssignMissionSlotResponse>>;
    public postV1MissionsMissionslugSlotsSlotuidAssign(authorization: string, missionSlug: string, slotUid: string, body?: Model68, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling postV1MissionsMissionslugSlotsSlotuidAssign.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling postV1MissionsMissionslugSlotsSlotuidAssign.');
        }
        if (slotUid === null || slotUid === undefined) {
            throw new Error('Required parameter slotUid was null or undefined when calling postV1MissionsMissionslugSlotsSlotuidAssign.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<AssignMissionSlotResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/slots/${encodeURIComponent(String(slotUid))}/assign`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Registers for the selected slot for the specified mission
     * Creates a new mission slot registration for the current user and the selected slot for the specified mission. An optional comment for the mission creator can be provided. Regular user authentication is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to create the slot registration for
     * @param slotUid UID of the mission slot to create registration for
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postV1MissionsMissionslugSlotsSlotuidRegistrations(authorization: string, missionSlug: string, slotUid: string, body?: Model72, observe?: 'body', reportProgress?: boolean): Observable<CreateMissionSlotRegistrationResponse>;
    public postV1MissionsMissionslugSlotsSlotuidRegistrations(authorization: string, missionSlug: string, slotUid: string, body?: Model72, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CreateMissionSlotRegistrationResponse>>;
    public postV1MissionsMissionslugSlotsSlotuidRegistrations(authorization: string, missionSlug: string, slotUid: string, body?: Model72, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CreateMissionSlotRegistrationResponse>>;
    public postV1MissionsMissionslugSlotsSlotuidRegistrations(authorization: string, missionSlug: string, slotUid: string, body?: Model72, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling postV1MissionsMissionslugSlotsSlotuidRegistrations.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling postV1MissionsMissionslugSlotsSlotuidRegistrations.');
        }
        if (slotUid === null || slotUid === undefined) {
            throw new Error('Required parameter slotUid was null or undefined when calling postV1MissionsMissionslugSlotsSlotuidRegistrations.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<CreateMissionSlotRegistrationResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/slots/${encodeURIComponent(String(slotUid))}/registrations`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Removes an existing assignment from a mission slot
     * Removes an existing assignment from a mission slot, removing any regular or external assignee. This endpoint can only be used by mission creators and users with the &#x60;mission.SLUG.editor&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to unassign slot
     * @param slotUid UID of the mission slot to unassign
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postV1MissionsMissionslugSlotsSlotuidUnassign(authorization: string, missionSlug: string, slotUid: string, observe?: 'body', reportProgress?: boolean): Observable<UnassignMissionSlotResponse>;
    public postV1MissionsMissionslugSlotsSlotuidUnassign(authorization: string, missionSlug: string, slotUid: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UnassignMissionSlotResponse>>;
    public postV1MissionsMissionslugSlotsSlotuidUnassign(authorization: string, missionSlug: string, slotUid: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UnassignMissionSlotResponse>>;
    public postV1MissionsMissionslugSlotsSlotuidUnassign(authorization: string, missionSlug: string, slotUid: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling postV1MissionsMissionslugSlotsSlotuidUnassign.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling postV1MissionsMissionslugSlotsSlotuidUnassign.');
        }
        if (slotUid === null || slotUid === undefined) {
            throw new Error('Required parameter slotUid was null or undefined when calling postV1MissionsMissionslugSlotsSlotuidUnassign.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.post<UnassignMissionSlotResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/slots/${encodeURIComponent(String(slotUid))}/unassign`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Applies the selected mission slot template to the mission
     * Applies the selected mission slot template to the mission, adding the slot groups and slots provided by it to the slotlist. This endpoint can only be used by mission creators and users with the &#x60;mission.SLUG.editor&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to apply slot template to
     * @param slotTemplateUid UID of the mission slot template to apply
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postV1MissionsMissionslugSlottemplatesSlottemplateuid(authorization: string, missionSlug: string, slotTemplateUid: string, body?: Model65, observe?: 'body', reportProgress?: boolean): Observable<ApplyMissionSlotTemplateResponse>;
    public postV1MissionsMissionslugSlottemplatesSlottemplateuid(authorization: string, missionSlug: string, slotTemplateUid: string, body?: Model65, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplyMissionSlotTemplateResponse>>;
    public postV1MissionsMissionslugSlottemplatesSlottemplateuid(authorization: string, missionSlug: string, slotTemplateUid: string, body?: Model65, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplyMissionSlotTemplateResponse>>;
    public postV1MissionsMissionslugSlottemplatesSlottemplateuid(authorization: string, missionSlug: string, slotTemplateUid: string, body?: Model65, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling postV1MissionsMissionslugSlottemplatesSlottemplateuid.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling postV1MissionsMissionslugSlottemplatesSlottemplateuid.');
        }
        if (slotTemplateUid === null || slotTemplateUid === undefined) {
            throw new Error('Required parameter slotTemplateUid was null or undefined when calling postV1MissionsMissionslugSlottemplatesSlottemplateuid.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<ApplyMissionSlotTemplateResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/slotTemplates/${encodeURIComponent(String(slotTemplateUid))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Generates a new mission token
     * Generates a new mission token for the current mission, overwriting and thus invalidating the current one. This endpoint can only be used by mission creators. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to generate mission token for
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postV1MissionsMissionslugToken(authorization: string, missionSlug: string, observe?: 'body', reportProgress?: boolean): Observable<GenerateMissionTokenResponse>;
    public postV1MissionsMissionslugToken(authorization: string, missionSlug: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenerateMissionTokenResponse>>;
    public postV1MissionsMissionslugToken(authorization: string, missionSlug: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenerateMissionTokenResponse>>;
    public postV1MissionsMissionslugToken(authorization: string, missionSlug: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling postV1MissionsMissionslugToken.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling postV1MissionsMissionslugToken.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.post<GenerateMissionTokenResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/token`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Sets the mission&#39;s banner image to the uploaded file
     * Sets the mission&#39;s banner image to the uploaded file - stored in GCP, max. image size is 2 Mebibyte. This endpoint can only be used by mission creators and users with the &#x60;mission.SLUG.editor&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param missionSlug Slug of mission to set banner image for
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putV1MissionsMissionslugBannerimage(authorization: string, missionSlug: string, body?: Model108, observe?: 'body', reportProgress?: boolean): Observable<UpdateMissionResponse>;
    public putV1MissionsMissionslugBannerimage(authorization: string, missionSlug: string, body?: Model108, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UpdateMissionResponse>>;
    public putV1MissionsMissionslugBannerimage(authorization: string, missionSlug: string, body?: Model108, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UpdateMissionResponse>>;
    public putV1MissionsMissionslugBannerimage(authorization: string, missionSlug: string, body?: Model108, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling putV1MissionsMissionslugBannerimage.');
        }
        if (missionSlug === null || missionSlug === undefined) {
            throw new Error('Required parameter missionSlug was null or undefined when calling putV1MissionsMissionslugBannerimage.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<UpdateMissionResponse>(`${this.basePath}/v1/missions/${encodeURIComponent(String(missionSlug))}/bannerImage`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}

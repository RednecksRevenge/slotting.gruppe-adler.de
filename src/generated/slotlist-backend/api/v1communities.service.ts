/**
 * slotlist.info API Documentation
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0-beta32
 * Contact: nick@slotlist.info
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { CreateCommunityApplicationResponse } from '../model/createCommunityApplicationResponse';
import { CreateCommunityPermissionResponse } from '../model/createCommunityPermissionResponse';
import { CreateCommunityResponse } from '../model/createCommunityResponse';
import { DeleteAccountResponse } from '../model/deleteAccountResponse';
import { DeleteCommunityResponse } from '../model/deleteCommunityResponse';
import { Forbidden } from '../model/forbidden';
import { GetCommunityApplicationListResponse } from '../model/getCommunityApplicationListResponse';
import { GetCommunityApplicationStatusResponse } from '../model/getCommunityApplicationStatusResponse';
import { GetCommunityDetailsResponse } from '../model/getCommunityDetailsResponse';
import { GetCommunityListResponse } from '../model/getCommunityListResponse';
import { GetCommunityMemberListResponse } from '../model/getCommunityMemberListResponse';
import { GetCommunityMissionListResponse } from '../model/getCommunityMissionListResponse';
import { GetCommunityPermissionListResponse } from '../model/getCommunityPermissionListResponse';
import { GetCommunityRepositoriesResponse } from '../model/getCommunityRepositoriesResponse';
import { GetCommunityServersResponse } from '../model/getCommunityServersResponse';
import { InternalServerError } from '../model/internalServerError';
import { IsCommunitySlugAvailableResponse } from '../model/isCommunitySlugAvailableResponse';
import { Model102 } from '../model/model102';
import { Model104 } from '../model/model104';
import { Model105 } from '../model/model105';
import { Model108 } from '../model/model108';
import { Model109 } from '../model/model109';
import { Model12 } from '../model/model12';
import { Model23 } from '../model/model23';
import { Model34 } from '../model/model34';
import { Model37 } from '../model/model37';
import { Model38 } from '../model/model38';
import { Model48 } from '../model/model48';
import { Model49 } from '../model/model49';
import { Model50 } from '../model/model50';
import { Model51 } from '../model/model51';
import { Model52 } from '../model/model52';
import { Model8 } from '../model/model8';
import { Model82 } from '../model/model82';
import { Model90 } from '../model/model90';
import { Model92 } from '../model/model92';
import { UpdateCommunityApplicationResponse } from '../model/updateCommunityApplicationResponse';
import { UpdateCommunityResponse } from '../model/updateCommunityResponse';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class V1communitiesService {

    protected basePath = 'https://api.slotlist.info';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Deletes an existing community
     * Deletes an existing community, including all associated applications. Removes all assocations with users and missions and deletes all community-related permissions. This endpoint can only be used by community founders. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param communitySlug Slug of community to delete
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteV1CommunitiesCommunityslug(authorization: string, communitySlug: string, observe?: 'body', reportProgress?: boolean): Observable<DeleteCommunityResponse>;
    public deleteV1CommunitiesCommunityslug(authorization: string, communitySlug: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DeleteCommunityResponse>>;
    public deleteV1CommunitiesCommunityslug(authorization: string, communitySlug: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DeleteCommunityResponse>>;
    public deleteV1CommunitiesCommunityslug(authorization: string, communitySlug: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteV1CommunitiesCommunityslug.');
        }
        if (communitySlug === null || communitySlug === undefined) {
            throw new Error('Required parameter communitySlug was null or undefined when calling deleteV1CommunitiesCommunityslug.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<DeleteCommunityResponse>(`${this.basePath}/v1/communities/${encodeURIComponent(String(communitySlug))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes an existing application to the community
     * Allows a user to delete their community application, also removing the user from the community if they were a member and deleting all their community permissions. Applications can only be deleted by the user that created them. Regular user authentication required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param communitySlug Slug of community to delete the application for
     * @param applicationUid UID of the community application to delete
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteV1CommunitiesCommunityslugApplicationsApplicationuid(authorization: string, communitySlug: string, applicationUid: string, observe?: 'body', reportProgress?: boolean): Observable<DeleteAccountResponse>;
    public deleteV1CommunitiesCommunityslugApplicationsApplicationuid(authorization: string, communitySlug: string, applicationUid: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DeleteAccountResponse>>;
    public deleteV1CommunitiesCommunityslugApplicationsApplicationuid(authorization: string, communitySlug: string, applicationUid: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DeleteAccountResponse>>;
    public deleteV1CommunitiesCommunityslugApplicationsApplicationuid(authorization: string, communitySlug: string, applicationUid: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteV1CommunitiesCommunityslugApplicationsApplicationuid.');
        }
        if (communitySlug === null || communitySlug === undefined) {
            throw new Error('Required parameter communitySlug was null or undefined when calling deleteV1CommunitiesCommunityslugApplicationsApplicationuid.');
        }
        if (applicationUid === null || applicationUid === undefined) {
            throw new Error('Required parameter applicationUid was null or undefined when calling deleteV1CommunitiesCommunityslugApplicationsApplicationuid.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<DeleteAccountResponse>(`${this.basePath}/v1/communities/${encodeURIComponent(String(communitySlug))}/applications/${encodeURIComponent(String(applicationUid))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes an existing community logo
     * Deletes an existing community logo, also removing it from GCP storage. This endpoint can only be used by community founders and users with the &#x60;community.SLUG.leader&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param communitySlug Slug of community to delete the logo for
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteV1CommunitiesCommunityslugLogo(authorization: string, communitySlug: string, observe?: 'body', reportProgress?: boolean): Observable<DeleteAccountResponse>;
    public deleteV1CommunitiesCommunityslugLogo(authorization: string, communitySlug: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DeleteAccountResponse>>;
    public deleteV1CommunitiesCommunityslugLogo(authorization: string, communitySlug: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DeleteAccountResponse>>;
    public deleteV1CommunitiesCommunityslugLogo(authorization: string, communitySlug: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteV1CommunitiesCommunityslugLogo.');
        }
        if (communitySlug === null || communitySlug === undefined) {
            throw new Error('Required parameter communitySlug was null or undefined when calling deleteV1CommunitiesCommunityslugLogo.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<DeleteAccountResponse>(`${this.basePath}/v1/communities/${encodeURIComponent(String(communitySlug))}/logo`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Removes a member from the community
     * Removes a member from the community, also deleting their community application as well as all community permissions. This endpoint can only be used by community leaders - community founders can not be removed by anyone beside admins. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param communitySlug Slug of community to remove member from
     * @param memberUid UID of the member to remove from the community
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteV1CommunitiesCommunityslugMembersMemberuid(authorization: string, communitySlug: string, memberUid: string, observe?: 'body', reportProgress?: boolean): Observable<DeleteAccountResponse>;
    public deleteV1CommunitiesCommunityslugMembersMemberuid(authorization: string, communitySlug: string, memberUid: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DeleteAccountResponse>>;
    public deleteV1CommunitiesCommunityslugMembersMemberuid(authorization: string, communitySlug: string, memberUid: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DeleteAccountResponse>>;
    public deleteV1CommunitiesCommunityslugMembersMemberuid(authorization: string, communitySlug: string, memberUid: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteV1CommunitiesCommunityslugMembersMemberuid.');
        }
        if (communitySlug === null || communitySlug === undefined) {
            throw new Error('Required parameter communitySlug was null or undefined when calling deleteV1CommunitiesCommunityslugMembersMemberuid.');
        }
        if (memberUid === null || memberUid === undefined) {
            throw new Error('Required parameter memberUid was null or undefined when calling deleteV1CommunitiesCommunityslugMembersMemberuid.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<DeleteAccountResponse>(`${this.basePath}/v1/communities/${encodeURIComponent(String(communitySlug))}/members/${encodeURIComponent(String(memberUid))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes an existing community permission
     * Deletes an existing community permission. This endpoint can only be used by community founders. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param communitySlug Slug of community to delete permission for
     * @param permissionUid UID of the community permission to delete
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteV1CommunitiesCommunityslugPermissionsPermissionuid(authorization: string, communitySlug: string, permissionUid: string, observe?: 'body', reportProgress?: boolean): Observable<DeleteAccountResponse>;
    public deleteV1CommunitiesCommunityslugPermissionsPermissionuid(authorization: string, communitySlug: string, permissionUid: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DeleteAccountResponse>>;
    public deleteV1CommunitiesCommunityslugPermissionsPermissionuid(authorization: string, communitySlug: string, permissionUid: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DeleteAccountResponse>>;
    public deleteV1CommunitiesCommunityslugPermissionsPermissionuid(authorization: string, communitySlug: string, permissionUid: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteV1CommunitiesCommunityslugPermissionsPermissionuid.');
        }
        if (communitySlug === null || communitySlug === undefined) {
            throw new Error('Required parameter communitySlug was null or undefined when calling deleteV1CommunitiesCommunityslugPermissionsPermissionuid.');
        }
        if (permissionUid === null || permissionUid === undefined) {
            throw new Error('Required parameter permissionUid was null or undefined when calling deleteV1CommunitiesCommunityslugPermissionsPermissionuid.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<DeleteAccountResponse>(`${this.basePath}/v1/communities/${encodeURIComponent(String(communitySlug))}/permissions/${encodeURIComponent(String(permissionUid))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a list of all currently created communities
     * Returns a paginated list of all currently created communities. Up to 100 communities can be requested at once, pagination has to be used to retrieve the rest. No authentication is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, optional
     * @param limit Limit for number of communities to retrieve, defaults to 25 (used for pagination in combination with offset)
     * @param offset Number of communities to skip before retrieving new ones from database, defaults to 0 (used for pagination in combination with limit)
     * @param search Value used for searching communities, retrieving only those that have a name or tag containing the provided value
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getV1Communities(authorization?: string, limit?: number, offset?: number, search?: string, observe?: 'body', reportProgress?: boolean): Observable<GetCommunityListResponse>;
    public getV1Communities(authorization?: string, limit?: number, offset?: number, search?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetCommunityListResponse>>;
    public getV1Communities(authorization?: string, limit?: number, offset?: number, search?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetCommunityListResponse>>;
    public getV1Communities(authorization?: string, limit?: number, offset?: number, search?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (search !== undefined) {
            queryParameters = queryParameters.set('search', <any>search);
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetCommunityListResponse>(`${this.basePath}/v1/communities`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns details about a specific community
     * Returns more detailed information about a specific community, including a short list of currently announced missions as well as a member list. No authentication is required to access this endpoint
     * @param communitySlug Slug of community to retrieve
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, optional
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getV1CommunitiesCommunityslug(communitySlug: string, authorization?: string, observe?: 'body', reportProgress?: boolean): Observable<GetCommunityDetailsResponse>;
    public getV1CommunitiesCommunityslug(communitySlug: string, authorization?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetCommunityDetailsResponse>>;
    public getV1CommunitiesCommunityslug(communitySlug: string, authorization?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetCommunityDetailsResponse>>;
    public getV1CommunitiesCommunityslug(communitySlug: string, authorization?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (communitySlug === null || communitySlug === undefined) {
            throw new Error('Required parameter communitySlug was null or undefined when calling getV1CommunitiesCommunityslug.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetCommunityDetailsResponse>(`${this.basePath}/v1/communities/${encodeURIComponent(String(communitySlug))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves a list of applications to the community
     * Returns a paginated list of users that have applied to the community. This endpoint can only be used by community leaders or members with the &#x60;community.SLUG.recruitment&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param communitySlug Slug of community to retrieve applications for
     * @param limit Limit for number of applications to retrieve, defaults to 25 (used for pagination in combination with offset)
     * @param offset Number of applications to skip before retrieving new ones from database, defaults to 0 (used for pagination in combination with limit)
     * @param status Allows for filtering of applications with the selected status. Takes preference over &#x60;includeProcessed&#x60; flag
     * @param includeProcessed Include processed applications (accepted/denied) in retrieved list, defaults to false. Is overwritten by &#x60;status&#x60; parameter
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getV1CommunitiesCommunityslugApplications(authorization: string, communitySlug: string, limit?: number, offset?: number, status?: string, includeProcessed?: boolean, observe?: 'body', reportProgress?: boolean): Observable<GetCommunityApplicationListResponse>;
    public getV1CommunitiesCommunityslugApplications(authorization: string, communitySlug: string, limit?: number, offset?: number, status?: string, includeProcessed?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetCommunityApplicationListResponse>>;
    public getV1CommunitiesCommunityslugApplications(authorization: string, communitySlug: string, limit?: number, offset?: number, status?: string, includeProcessed?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetCommunityApplicationListResponse>>;
    public getV1CommunitiesCommunityslugApplications(authorization: string, communitySlug: string, limit?: number, offset?: number, status?: string, includeProcessed?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getV1CommunitiesCommunityslugApplications.');
        }
        if (communitySlug === null || communitySlug === undefined) {
            throw new Error('Required parameter communitySlug was null or undefined when calling getV1CommunitiesCommunityslugApplications.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (status !== undefined) {
            queryParameters = queryParameters.set('status', <any>status);
        }
        if (includeProcessed !== undefined) {
            queryParameters = queryParameters.set('includeProcessed', <any>includeProcessed);
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetCommunityApplicationListResponse>(`${this.basePath}/v1/communities/${encodeURIComponent(String(communitySlug))}/applications`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve the status of a user&#39;s community application
     * Retrieves the status of a user&#39;s community application, also returning the community application UID used for deleting the application. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param communitySlug Slug of community to get the application status for
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getV1CommunitiesCommunityslugApplicationsStatus(authorization: string, communitySlug: string, observe?: 'body', reportProgress?: boolean): Observable<GetCommunityApplicationStatusResponse>;
    public getV1CommunitiesCommunityslugApplicationsStatus(authorization: string, communitySlug: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetCommunityApplicationStatusResponse>>;
    public getV1CommunitiesCommunityslugApplicationsStatus(authorization: string, communitySlug: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetCommunityApplicationStatusResponse>>;
    public getV1CommunitiesCommunityslugApplicationsStatus(authorization: string, communitySlug: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getV1CommunitiesCommunityslugApplicationsStatus.');
        }
        if (communitySlug === null || communitySlug === undefined) {
            throw new Error('Required parameter communitySlug was null or undefined when calling getV1CommunitiesCommunityslugApplicationsStatus.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetCommunityApplicationStatusResponse>(`${this.basePath}/v1/communities/${encodeURIComponent(String(communitySlug))}/applications/status`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a list of members of a specific community
     * Returns a paginated list of members of a specific community, including leadership. Allows for member lists to be refresh without having to fetch all other community details. No authentication is required to access this endpoint
     * @param communitySlug Slug of community to retrieve
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, optional
     * @param limit Limit for number of members to retrieve, defaults to 25 (used for pagination in combination with offset)
     * @param offset Number of members to skip before retrieving new ones from database, defaults to 0 (used for pagination in combination with limit)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getV1CommunitiesCommunityslugMembers(communitySlug: string, authorization?: string, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean): Observable<GetCommunityMemberListResponse>;
    public getV1CommunitiesCommunityslugMembers(communitySlug: string, authorization?: string, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetCommunityMemberListResponse>>;
    public getV1CommunitiesCommunityslugMembers(communitySlug: string, authorization?: string, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetCommunityMemberListResponse>>;
    public getV1CommunitiesCommunityslugMembers(communitySlug: string, authorization?: string, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (communitySlug === null || communitySlug === undefined) {
            throw new Error('Required parameter communitySlug was null or undefined when calling getV1CommunitiesCommunityslugMembers.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetCommunityMemberListResponse>(`${this.basePath}/v1/communities/${encodeURIComponent(String(communitySlug))}/members`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a list of missions for a specific community
     * Returns a paginated list of missions for a specific community, including already completed ones. Allows for mission lists to be refresh without having to fetch all other community details. No authentication is required to access this endpoint
     * @param communitySlug Slug of community to retrieve
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, optional
     * @param limit Limit for number of missions to retrieve, defaults to 25 (used for pagination in combination with offset)
     * @param offset Number of missions to skip before retrieving new ones from database, defaults to 0 (used for pagination in combination with limit)
     * @param includeEnded Include ended missions in retrieved list, defaults to false
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getV1CommunitiesCommunityslugMissions(communitySlug: string, authorization?: string, limit?: number, offset?: number, includeEnded?: boolean, observe?: 'body', reportProgress?: boolean): Observable<GetCommunityMissionListResponse>;
    public getV1CommunitiesCommunityslugMissions(communitySlug: string, authorization?: string, limit?: number, offset?: number, includeEnded?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetCommunityMissionListResponse>>;
    public getV1CommunitiesCommunityslugMissions(communitySlug: string, authorization?: string, limit?: number, offset?: number, includeEnded?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetCommunityMissionListResponse>>;
    public getV1CommunitiesCommunityslugMissions(communitySlug: string, authorization?: string, limit?: number, offset?: number, includeEnded?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (communitySlug === null || communitySlug === undefined) {
            throw new Error('Required parameter communitySlug was null or undefined when calling getV1CommunitiesCommunityslugMissions.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (includeEnded !== undefined) {
            queryParameters = queryParameters.set('includeEnded', <any>includeEnded);
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetCommunityMissionListResponse>(`${this.basePath}/v1/communities/${encodeURIComponent(String(communitySlug))}/missions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a list of all permissions granted for the given community
     * Returns a list of permissions granted for the given community. This endpoint can only be used by community founders. Regular user authentication with appropriate  permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param communitySlug Slug of community to retrieve permissions for
     * @param limit Limit for number of permissions to retrieve, defaults to 25 (used for pagination in combination with offset)
     * @param offset Number of permissions to skip before retrieving new ones from database, defaults to 0 (used for pagination in combination with limit)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getV1CommunitiesCommunityslugPermissions(authorization: string, communitySlug: string, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean): Observable<GetCommunityPermissionListResponse>;
    public getV1CommunitiesCommunityslugPermissions(authorization: string, communitySlug: string, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetCommunityPermissionListResponse>>;
    public getV1CommunitiesCommunityslugPermissions(authorization: string, communitySlug: string, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetCommunityPermissionListResponse>>;
    public getV1CommunitiesCommunityslugPermissions(authorization: string, communitySlug: string, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getV1CommunitiesCommunityslugPermissions.');
        }
        if (communitySlug === null || communitySlug === undefined) {
            throw new Error('Required parameter communitySlug was null or undefined when calling getV1CommunitiesCommunityslugPermissions.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (offset !== undefined) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetCommunityPermissionListResponse>(`${this.basePath}/v1/communities/${encodeURIComponent(String(communitySlug))}/permissions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a list of mod repositories defined for a specific community
     * Returns a list of mod repositories defined for a specific community, allowing for mission creators to quickly fill out the mission&#39;s mod repo repo information. This endpoint is only accessible to community members. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param communitySlug Slug of community to retrieve repositories for
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getV1CommunitiesCommunityslugRepositories(authorization: string, communitySlug: string, observe?: 'body', reportProgress?: boolean): Observable<GetCommunityRepositoriesResponse>;
    public getV1CommunitiesCommunityslugRepositories(authorization: string, communitySlug: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetCommunityRepositoriesResponse>>;
    public getV1CommunitiesCommunityslugRepositories(authorization: string, communitySlug: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetCommunityRepositoriesResponse>>;
    public getV1CommunitiesCommunityslugRepositories(authorization: string, communitySlug: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getV1CommunitiesCommunityslugRepositories.');
        }
        if (communitySlug === null || communitySlug === undefined) {
            throw new Error('Required parameter communitySlug was null or undefined when calling getV1CommunitiesCommunityslugRepositories.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetCommunityRepositoriesResponse>(`${this.basePath}/v1/communities/${encodeURIComponent(String(communitySlug))}/repositories`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a list of game and voice comms servers defined for a specific community
     * Returns a list of game and voice comms servers defined for a specific community, allowing for mission creators to quickly fill out the mission&#39;s gameserver and voice comms information. This endpoint is only accessible to community members. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param communitySlug Slug of community to retrieve servers for
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getV1CommunitiesCommunityslugServers(authorization: string, communitySlug: string, observe?: 'body', reportProgress?: boolean): Observable<GetCommunityServersResponse>;
    public getV1CommunitiesCommunityslugServers(authorization: string, communitySlug: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetCommunityServersResponse>>;
    public getV1CommunitiesCommunityslugServers(authorization: string, communitySlug: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetCommunityServersResponse>>;
    public getV1CommunitiesCommunityslugServers(authorization: string, communitySlug: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getV1CommunitiesCommunityslugServers.');
        }
        if (communitySlug === null || communitySlug === undefined) {
            throw new Error('Required parameter communitySlug was null or undefined when calling getV1CommunitiesCommunityslugServers.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetCommunityServersResponse>(`${this.basePath}/v1/communities/${encodeURIComponent(String(communitySlug))}/servers`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Checks whether the given slug is available
     * Checks whether the given slug is available and can be used for a new community. No authentication is required to access this endpoint
     * @param slug Slug to check availability for
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, optional
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getV1CommunitiesSlugavailable(slug: string, authorization?: string, observe?: 'body', reportProgress?: boolean): Observable<IsCommunitySlugAvailableResponse>;
    public getV1CommunitiesSlugavailable(slug: string, authorization?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<IsCommunitySlugAvailableResponse>>;
    public getV1CommunitiesSlugavailable(slug: string, authorization?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<IsCommunitySlugAvailableResponse>>;
    public getV1CommunitiesSlugavailable(slug: string, authorization?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (slug === null || slug === undefined) {
            throw new Error('Required parameter slug was null or undefined when calling getV1CommunitiesSlugavailable.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (slug !== undefined) {
            queryParameters = queryParameters.set('slug', <any>slug);
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<IsCommunitySlugAvailableResponse>(`${this.basePath}/v1/communities/slugAvailable`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates an existing community
     * Updates the mutable attributes of a community. This endpoint can only be used by community leaders. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param communitySlug Slug of community to update
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchV1CommunitiesCommunityslug(authorization: string, communitySlug: string, body?: Model82, observe?: 'body', reportProgress?: boolean): Observable<UpdateCommunityResponse>;
    public patchV1CommunitiesCommunityslug(authorization: string, communitySlug: string, body?: Model82, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UpdateCommunityResponse>>;
    public patchV1CommunitiesCommunityslug(authorization: string, communitySlug: string, body?: Model82, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UpdateCommunityResponse>>;
    public patchV1CommunitiesCommunityslug(authorization: string, communitySlug: string, body?: Model82, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling patchV1CommunitiesCommunityslug.');
        }
        if (communitySlug === null || communitySlug === undefined) {
            throw new Error('Required parameter communitySlug was null or undefined when calling patchV1CommunitiesCommunityslug.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.patch<UpdateCommunityResponse>(`${this.basePath}/v1/communities/${encodeURIComponent(String(communitySlug))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates an existing application to the community
     * Updates an existing application to the community, accepting or denying it. This endpoint can only be used by community leaders or members with the &#x60;community.SLUG.recruitment&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param communitySlug Slug of community to update the application for
     * @param applicationUid UID of the community application to update
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public patchV1CommunitiesCommunityslugApplicationsApplicationuid(authorization: string, communitySlug: string, applicationUid: string, body?: Model90, observe?: 'body', reportProgress?: boolean): Observable<UpdateCommunityApplicationResponse>;
    public patchV1CommunitiesCommunityslugApplicationsApplicationuid(authorization: string, communitySlug: string, applicationUid: string, body?: Model90, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UpdateCommunityApplicationResponse>>;
    public patchV1CommunitiesCommunityslugApplicationsApplicationuid(authorization: string, communitySlug: string, applicationUid: string, body?: Model90, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UpdateCommunityApplicationResponse>>;
    public patchV1CommunitiesCommunityslugApplicationsApplicationuid(authorization: string, communitySlug: string, applicationUid: string, body?: Model90, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling patchV1CommunitiesCommunityslugApplicationsApplicationuid.');
        }
        if (communitySlug === null || communitySlug === undefined) {
            throw new Error('Required parameter communitySlug was null or undefined when calling patchV1CommunitiesCommunityslugApplicationsApplicationuid.');
        }
        if (applicationUid === null || applicationUid === undefined) {
            throw new Error('Required parameter applicationUid was null or undefined when calling patchV1CommunitiesCommunityslugApplicationsApplicationuid.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.patch<UpdateCommunityApplicationResponse>(`${this.basePath}/v1/communities/${encodeURIComponent(String(communitySlug))}/applications/${encodeURIComponent(String(applicationUid))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new community
     * Creates a new community and assigns the current user as its founder. Regular user authentication is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postV1Communities(authorization: string, body?: Model37, observe?: 'body', reportProgress?: boolean): Observable<CreateCommunityResponse>;
    public postV1Communities(authorization: string, body?: Model37, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CreateCommunityResponse>>;
    public postV1Communities(authorization: string, body?: Model37, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CreateCommunityResponse>>;
    public postV1Communities(authorization: string, body?: Model37, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling postV1Communities.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<CreateCommunityResponse>(`${this.basePath}/v1/communities`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Applies to join the specified community
     * Applies to join the specified community, has to be approved by community leader or members with the &#x60;community.SLUG.recruitment&#x60; permission. Regular user authentication is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param communitySlug Slug of community to apply to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postV1CommunitiesCommunityslugApplications(authorization: string, communitySlug: string, observe?: 'body', reportProgress?: boolean): Observable<CreateCommunityApplicationResponse>;
    public postV1CommunitiesCommunityslugApplications(authorization: string, communitySlug: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CreateCommunityApplicationResponse>>;
    public postV1CommunitiesCommunityslugApplications(authorization: string, communitySlug: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CreateCommunityApplicationResponse>>;
    public postV1CommunitiesCommunityslugApplications(authorization: string, communitySlug: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling postV1CommunitiesCommunityslugApplications.');
        }
        if (communitySlug === null || communitySlug === undefined) {
            throw new Error('Required parameter communitySlug was null or undefined when calling postV1CommunitiesCommunityslugApplications.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.post<CreateCommunityApplicationResponse>(`${this.basePath}/v1/communities/${encodeURIComponent(String(communitySlug))}/applications`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new community permission for the given community
     * Creates a new community permission for the given community. This endpoint can only be used by community founders. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param communitySlug Slug of community to create permission for
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postV1CommunitiesCommunityslugPermissions(authorization: string, communitySlug: string, body?: Model48, observe?: 'body', reportProgress?: boolean): Observable<CreateCommunityPermissionResponse>;
    public postV1CommunitiesCommunityslugPermissions(authorization: string, communitySlug: string, body?: Model48, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CreateCommunityPermissionResponse>>;
    public postV1CommunitiesCommunityslugPermissions(authorization: string, communitySlug: string, body?: Model48, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CreateCommunityPermissionResponse>>;
    public postV1CommunitiesCommunityslugPermissions(authorization: string, communitySlug: string, body?: Model48, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling postV1CommunitiesCommunityslugPermissions.');
        }
        if (communitySlug === null || communitySlug === undefined) {
            throw new Error('Required parameter communitySlug was null or undefined when calling postV1CommunitiesCommunityslugPermissions.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<CreateCommunityPermissionResponse>(`${this.basePath}/v1/communities/${encodeURIComponent(String(communitySlug))}/permissions`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Sets the community&#39;s logo to the uploaded file
     * Sets the community&#39;s logo to the uploaded file - stored in GCP, max. image size is 2 Mebibyte. This endpoint can only be used by community founders and users with the &#x60;community.SLUG.leader&#x60; permission. Regular user authentication with appropriate permissions is required to access this endpoint
     * @param authorization &#x60;JWT &lt;TOKEN&gt;&#x60; used for authorization, required
     * @param communitySlug Slug of community to set logo for
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putV1CommunitiesCommunityslugLogo(authorization: string, communitySlug: string, body?: Model108, observe?: 'body', reportProgress?: boolean): Observable<UpdateCommunityResponse>;
    public putV1CommunitiesCommunityslugLogo(authorization: string, communitySlug: string, body?: Model108, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UpdateCommunityResponse>>;
    public putV1CommunitiesCommunityslugLogo(authorization: string, communitySlug: string, body?: Model108, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UpdateCommunityResponse>>;
    public putV1CommunitiesCommunityslugLogo(authorization: string, communitySlug: string, body?: Model108, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling putV1CommunitiesCommunityslugLogo.');
        }
        if (communitySlug === null || communitySlug === undefined) {
            throw new Error('Required parameter communitySlug was null or undefined when calling putV1CommunitiesCommunityslugLogo.');
        }

        let headers = this.defaultHeaders;
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('authorization', String(authorization));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<UpdateCommunityResponse>(`${this.basePath}/v1/communities/${encodeURIComponent(String(communitySlug))}/logo`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
